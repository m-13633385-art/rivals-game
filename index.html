import * as THREE from 'three';

// --- 1. NETWORKING & STATE ---
const peer = new Peer();
let conn;
let myHp = 100;
let canShoot = true;

const myIdDisplay = document.getElementById('my-id');
const lobby = document.getElementById('lobby');
const ui = document.getElementById('ui');

peer.on('open', (id) => { myIdDisplay.innerText = id; });

peer.on('connection', (c) => {
    conn = c;
    setupMultiplayer();
    startMatch();
});

document.getElementById('join-btn').onclick = () => {
    conn = peer.connect(document.getElementById('join-input').value);
    setupMultiplayer();
    startMatch();
};

function setupMultiplayer() {
    conn.on('data', (data) => {
        if (data.type === 'move') {
            opponent.position.set(data.x, data.y, data.z);
            opponent.rotation.y = data.ry;
        }
        if (data.type === 'shoot') {
            showFlash(opponent);
        }
        if (data.type === 'hit') {
            takeDamage(data.damage);
        }
    });
}

// --- 2. 3D SCENE ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050505);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshPhongMaterial({ color: 0x111111 }));
floor.rotation.x = -Math.PI/2;
scene.add(floor);
scene.add(new THREE.AmbientLight(0xffffff, 0.5));

// Opponent Model
const opponent = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2, 1.2), new THREE.MeshPhongMaterial({ color: 0xff0000 }));
opponent.position.y = 1;
scene.add(opponent);

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2(0, 0); // Center of screen

// --- 3. COMBAT LOGIC ---
function takeDamage(amount) {
    myHp -= amount;
    ui.innerText = `HP: ${myHp} | ONLINE: CONNECTED`;
    document.body.style.backgroundColor = "red"; // Screen flash red
    setTimeout(() => document.body.style.backgroundColor = "black", 100);

    if (myHp <= 0) {
        alert("YOU DIED! Resetting...");
        myHp = 100;
        camera.position.set(Math.random() * 10, 1.6, Math.random() * 10);
        ui.innerText = `HP: ${myHp} | ONLINE: CONNECTED`;
    }
}

function shoot() {
    if (!canShoot) return;
    canShoot = false;
    setTimeout(() => canShoot = true, 200); // Fire rate limit

    showFlash(camera);
    conn.send({ type: 'shoot' });

    // HIT DETECTION
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(opponent);

    if (intersects.length > 0) {
        console.log("HIT CONFIRMED!");
        conn.send({ type: 'hit', damage: 20 });
    }
}

function showFlash(source) {
    const p = new THREE.PointLight(0xffff00, 15, 10);
    p.position.copy(source.position);
    scene.add(p);
    setTimeout(() => scene.remove(p), 50);
}

// --- 4. CONTROLS & LOOP ---
document.addEventListener('mousedown', () => {
    if (document.pointerLockElement === document.body && conn) shoot();
});

let keys = {};
document.onkeydown = (e) => keys[e.code] = true;
document.onkeyup = (e) => keys[e.code] = false;

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        camera.rotation.y -= e.movementX * 0.002;
        camera.rotation.x -= e.movementY * 0.002;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }
});
camera.rotation.order = 'YXZ';

function startMatch() {
    lobby.style.display = 'none';
    document.body.requestPointerLock();
    animate();
}

function animate() {
    requestAnimationFrame(animate);
    if (document.pointerLockElement === document.body) {
        const speed = 0.12;
        if (keys['KeyW']) camera.translateZ(-speed);
        if (keys['KeyS']) camera.translateZ(speed);
        if (keys['KeyA']) camera.translateX(-speed);
        if (keys['KeyD']) camera.translateX(speed);
        camera.position.y = 1.6;

        if (conn && conn.open) {
            conn.send({ type: 'move', x: camera.position.x, y: 0, z: camera.position.z, ry: camera.rotation.y });
        }
    }
    renderer.render(scene, camera);
}
